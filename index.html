<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dungeon Crawl Mapper</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Use dvh for mobile browsers to avoid bottom bar cutoff */
        body { background-color: #030712; color: white; overflow: hidden; touch-action: none; height: 100vh; height: 100dvh; }
        #root { height: 100%; display: flex; flex-direction: column; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none;  scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const IconWrapper = ({ children, className, size = 24 }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
            >
                {children}
            </svg>
        );

        const ArrowUp = (props) => <IconWrapper {...props}><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></IconWrapper>;
        const ArrowLeft = (props) => <IconWrapper {...props}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></IconWrapper>;
        const ArrowRight = (props) => <IconWrapper {...props}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></IconWrapper>;
        const AlertTriangle = (props) => <IconWrapper {...props}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></IconWrapper>;
        const Skull = (props) => <IconWrapper {...props}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></IconWrapper>;
        const Coins = (props) => <IconWrapper {...props}><circle cx="8" cy="8" r="6"/><path d="M18.09 10.37A6 6 0 1 1 10.34 18"/><path d="M7 6h1v4"/><path d="m16.71 13.88.7.71-2.82 2.82"/></IconWrapper>;
        const Circle = (props) => <IconWrapper {...props}><circle cx="12" cy="12" r="10"/></IconWrapper>;
        const ChevronsUp = (props) => <IconWrapper {...props}><path d="m17 11-5-5-5 5"/><path d="m17 18-5-5-5 5"/></IconWrapper>;
        const Sword = (props) => <IconWrapper {...props}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" x2="19" y1="19" y2="13"/><line x1="16" x2="20" y1="16" y2="20"/><line x1="19" x2="21" y1="21" y2="19"/></IconWrapper>;
        const Check = (props) => <IconWrapper {...props}><polyline points="20 6 9 17 4 12"/></IconWrapper>;
        const Share2 = (props) => <IconWrapper {...props}><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"/><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"/></IconWrapper>;


        // --- Initial Data Generator ---
        const getInitialData = () => Array(5).fill(null).map((_, i) => ({
            level: i + 1,
            nodes: {
                'root': { id: 'root', type: 'intersection', exits: [], parent: null, x: 0, y: 0 }
            }
        }));

        function DungeonMapper() {
            const [maps, setMaps] = useState(getInitialData());
            const [currentLevel, setCurrentLevel] = useState(1);
            const [cursor, setCursor] = useState({ nodeId: 'root', previousNodeId: null, directionFromPrev: null });
            const [mode, setMode] = useState('IDLE'); 
            const [draftExits, setDraftExits] = useState([]); 
            const [message, setMessage] = useState("Select Level to Start");

            // --- URL Import Logic ---
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const sharedData = params.get('map_data');

                if (sharedData) {
                    try {
                        const decoded = JSON.parse(atob(sharedData));
                        if (Array.isArray(decoded) && decoded.length === 5) {
                            if (window.confirm("ðŸ“¥ Shared Dungeon Found!\n\nLoad this map? This will overwrite your current progress.")) {
                                setMaps(decoded);
                                localStorage.setItem('stern_dnd_map_v4', JSON.stringify(decoded));
                                setMessage("Shared Map Loaded!");
                                setCursor({ nodeId: 'root', previousNodeId: null, directionFromPrev: null });
                                setMode('IDLE');
                            }
                        }
                    } catch (e) {
                        console.error("Invalid map data", e);
                        setMessage("Error loading shared map");
                    }
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }, []);

            // --- Persist ---
            useEffect(() => {
                const saved = localStorage.getItem('stern_dnd_map_v4');
                if (saved && !window.location.search.includes('map_data')) {
                   try { setMaps(JSON.parse(saved)); } catch (e) { console.error(e); }
                }
            }, []);

            useEffect(() => {
                localStorage.setItem('stern_dnd_map_v4', JSON.stringify(maps));
            }, [maps]);

            const getNode = (id) => maps[currentLevel - 1].nodes[id];
            
            const startLevel = (lvl) => {
                setCurrentLevel(lvl);
                setCursor({ nodeId: 'root', previousNodeId: null, directionFromPrev: null });
                
                const lvlMap = maps[lvl - 1];
                const rootNode = lvlMap.nodes['root'];

                if (rootNode.exits.length === 0) {
                    setMode('DEFINING');
                    setDraftExits([]);
                    setMessage(`Level ${lvl}: Define entry paths`);
                } else {
                    setMode('IDLE');
                    setMessage(`Level ${lvl}: Ready`);
                }
            };

            // --- Sharing ---
            const handleShare = () => {
                try {
                    const json = JSON.stringify(maps);
                    const encoded = btoa(json);
                    const url = `${window.location.origin}${window.location.pathname}?map_data=${encoded}`;
                    navigator.clipboard.writeText(url).then(() => {
                        setMessage("ðŸ“‹ Link Copied!");
                        setTimeout(() => setMessage("Ready"), 3000);
                    });
                } catch (e) {
                    setMessage("Error creating link");
                }
            };

            // --- Navigation ---
            const handleNodeClick = (clickedNode, levelIndex) => {
                const targetLvl = levelIndex + 1;
                
                if (clickedNode.id.toString().startsWith('stub_')) {
                    if (targetLvl !== currentLevel) setCurrentLevel(targetLvl);
                    const parentNode = maps[levelIndex].nodes[clickedNode.parentId];
                    setCursor({ nodeId: parentNode.id, previousNodeId: parentNode.parent, directionFromPrev: null });
                    setMode('IDLE');
                    setMessage("Moved to Intersection.");
                    return;
                }

                const node = maps[levelIndex].nodes[clickedNode.id];
                if (!node) return;

                if (targetLvl !== currentLevel) setCurrentLevel(targetLvl);

                setCursor({ nodeId: node.id, previousNodeId: node.parent, directionFromPrev: null });
                setDraftExits([]);

                if (node.type === 'unknown') {
                    setMode('TRANSIT');
                    setMessage("Exploring... What is here?");
                } else if (node.type === 'intersection' && node.exits.length === 0) {
                    setMode('DEFINING');
                    setMessage("New Intersection. Define paths.");
                } else if (node.type === 'enemy' && node.exits.length === 0) {
                    setMode('IDLE');
                    setMessage("Enemy! Defeat & Press GO.");
                } else {
                    setMode('IDLE');
                    setMessage(`Jumped to ${node.type}.`);
                }
            };

            // --- Input Handler ---
            const handleInput = (keyInput, codeInput = null) => {
                const key = keyInput.toUpperCase();
                
                if (key === 'DELETE') {
                    if (window.confirm("âš ï¸ Reset Map?\n\nThis will delete all progress on ALL levels.")) {
                        const freshData = getInitialData();
                        setMaps(freshData);
                        setCurrentLevel(1);
                        setCursor({ nodeId: 'root', previousNodeId: null, directionFromPrev: null });
                        setMode('DEFINING'); 
                        setDraftExits([]);
                        setMessage("Map Reset");
                        localStorage.removeItem('stern_dnd_map_v4');
                    }
                    return;
                }
                
                if (['1', '2', '3', '4', '5'].includes(key)) {
                    startLevel(parseInt(key));
                    return;
                }

                if (mode === 'DEFINING') handleDefiningInput(key);
                else if (mode === 'IDLE') handleIdleInput(key, codeInput);
                else if (mode === 'TRANSIT') handleTransitInput(key, codeInput);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    handleInput(e.key, e.code);
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [mode, currentLevel, cursor, draftExits, maps]);

            // --- Mode Logic ---

            const handleDefiningInput = (key) => {
                const mapping = { 'A': 'left', 'S': 'center', 'D': 'right' };
                if (mapping[key]) {
                    const dir = mapping[key];
                    setDraftExits(prev => prev.includes(dir) ? prev.filter(d => d !== dir) : [...prev, dir]);
                } else if (key === 'ENTER') {
                    if (draftExits.length === 0) {
                        setMessage("Select at least 1 path");
                        return;
                    }
                    const newMaps = [...maps];
                    const node = newMaps[currentLevel - 1].nodes[cursor.nodeId];
                    node.exits = draftExits.map(d => ({ dir: d, targetId: null }));
                    setMaps(newMaps);
                    setMode('IDLE');
                    setMessage("Mapped. Choose direction.");
                }
            };

            const handleIdleInput = (key, code) => {
                const node = getNode(cursor.nodeId);
                
                // Battle Victory Logic
                if (node.type === 'enemy') {
                    const isCleared = node.exits.length > 0;
                    if (!isCleared) {
                        if (key === 'ENTER' || code === 'Space') {
                                const newMaps = [...maps];
                                const activeMap = newMaps[currentLevel - 1];
                                const battleNodeId = cursor.nodeId;
                                
                                const newId = `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                                activeMap.nodes[newId] = {
                                    id: newId,
                                    type: 'unknown', 
                                    exits: [],
                                    parent: battleNodeId
                                };
                                
                                activeMap.nodes[battleNodeId].exits = [{ dir: 'center', targetId: newId }];
                                
                                setMaps(newMaps);
                                setCursor({ nodeId: newId, previousNodeId: battleNodeId, directionFromPrev: 'center' });
                                setMode('TRANSIT');
                                setMessage("Victory! What's next?");
                                return;
                        } else {
                            setMessage("Enemy! Defeat & Press GO.");
                            return;
                        }
                    }
                }

                const mapping = { 'A': 'left', 'S': 'center', 'D': 'right' };
                const dir = mapping[key];
                if (!dir) return;

                const exit = node.exits.find(e => e.dir === dir);
                if (!exit) {
                    setMessage(`Invalid Move`);
                    return;
                }

                if (exit.targetId) {
                    const targetNode = getNode(exit.targetId);
                    moveToNode(exit.targetId, dir, targetNode);
                } else {
                    setCursor({ nodeId: null, previousNodeId: cursor.nodeId, directionFromPrev: dir });
                    setMode('TRANSIT');
                    setMessage(`Exploring... What did you find?`);
                }
            };

            const moveToNode = (targetId, dirFromPrev, targetNode) => {
                setCursor({ nodeId: targetId, previousNodeId: cursor.nodeId, directionFromPrev: dirFromPrev });
                
                if (targetNode.type === 'unknown') {
                    setMode('TRANSIT');
                    setMessage("Exploring... What did you find?");
                } else if (targetNode.type === 'intersection' && targetNode.exits.length === 0) {
                    setMode('DEFINING');
                    setDraftExits([]);
                    setMessage("New Room. Define Paths.");
                } else if (targetNode.type === 'enemy') {
                    const isCleared = targetNode.exits.length > 0;
                    setMode('IDLE'); 
                    setMessage(isCleared ? "Defeated Enemy." : "Battle! Press GO when won.");
                } else {
                    setMode('IDLE');
                    setMessage(`At ${targetNode.type}.`);
                }
            }

            const handleTransitInput = (key, code) => {
                let newNodeType = null;
                let nextMode = 'IDLE';
                let content = '';
                let connectionDir = cursor.directionFromPrev; 
                
                if (key === 'X') newNodeType = 'trap';
                else if (key === 'B') newNodeType = 'enemy';
                else if (key === 'G') newNodeType = 'treasure';
                else if (key === 'E') newNodeType = 'extra_ball';
                else if (code === 'Space') { newNodeType = 'stairs'; content = (currentLevel + 1).toString(); }
                else if (['A', 'S', 'D'].includes(key)) {
                    newNodeType = 'intersection';
                    nextMode = 'DEFINING';
                }

                if (!newNodeType) return;

                const newMaps = [...maps];
                const activeMap = newMaps[currentLevel - 1];

                if (cursor.nodeId && activeMap.nodes[cursor.nodeId]?.type === 'unknown') {
                     const node = activeMap.nodes[cursor.nodeId];
                     node.type = newNodeType;
                     node.content = content;
                     
                     setMaps(newMaps);
                     setMode(nextMode);
                     
                     if (newNodeType === 'enemy') setMessage("Enemy! Win -> GO");
                     else if (nextMode === 'DEFINING') {
                         setDraftExits([]);
                         setMessage("Intersection. Define paths.");
                     } else {
                         setMessage(`Found ${newNodeType}.`);
                     }
                     return;
                }

                const newId = `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                activeMap.nodes[newId] = {
                    id: newId,
                    type: newNodeType,
                    exits: [],
                    content: content,
                    parent: cursor.previousNodeId
                };

                const parentNode = activeMap.nodes[cursor.previousNodeId];
                const exitIndex = parentNode.exits.findIndex(e => e.dir === connectionDir);
                if (exitIndex >= 0) {
                    parentNode.exits[exitIndex].targetId = newId;
                }

                setMaps(newMaps);
                setCursor({ nodeId: newId, previousNodeId: cursor.previousNodeId, directionFromPrev: connectionDir });
                setMode(nextMode);
                
                if (newNodeType === 'enemy') setMessage("Enemy! Win -> GO");
                else if (nextMode === 'DEFINING') {
                    setDraftExits([]);
                    setMessage("Intersection. Define paths.");
                } else {
                    setMessage(`Found ${newNodeType}.`);
                }
            };

            // --- Layout & Rendering ---
            const computeLayout = (levelIndex) => {
                const activeMap = maps[levelIndex];
                const nodes = activeMap.nodes;
                const rootId = 'root';
                
                const getAllChildren = (id) => {
                    const n = nodes[id];
                    if (!n) return [];
                    const order = { 'left': -1, 'center': 0, 'right': 1, 'next': 0 };
                    return [...n.exits].sort((a,b) => order[a.dir] - order[b.dir]);
                };

                const NODE_WIDTH = 60; 
                const subtreeWidths = {};

                const computeWidth = (id) => {
                    const children = getAllChildren(id);
                    if (children.length === 0) {
                        subtreeWidths[id] = NODE_WIDTH;
                        return NODE_WIDTH;
                    }
                    let width = 0;
                    children.forEach(c => {
                        width += c.targetId ? computeWidth(c.targetId) : NODE_WIDTH;
                    });
                    subtreeWidths[id] = width;
                    return width;
                };
                
                computeWidth(rootId);

                const coords = {};
                const stubCoords = {}; 
                const Y_SPACING = 80; 

                const assignPos = (id, x, y) => {
                    coords[id] = { x, y };
                    const children = getAllChildren(id);
                    if (children.length === 0) return;
                    
                    let currentX = x - (subtreeWidths[id] / 2);
                    
                    children.forEach(child => {
                        let childW = NODE_WIDTH; 
                        if (child.targetId) childW = subtreeWidths[child.targetId];

                        const childCenterX = currentX + (childW / 2);
                        
                        if (child.targetId) {
                            assignPos(child.targetId, childCenterX, y - Y_SPACING);
                        } else {
                            stubCoords[`stub_${id}_${child.dir}`] = {
                                x: childCenterX,
                                y: y - Y_SPACING,
                                parentId: id,
                                dir: child.dir
                            };
                        }
                        currentX += childW;
                    });
                };

                assignPos(rootId, 0, 0);

                const renderNodes = Object.keys(coords).map(id => ({ ...nodes[id], ...coords[id] }));
                const renderEdges = [];
                const renderStubs = [];

                renderNodes.forEach(node => {
                    node.exits.forEach(exit => {
                        if (exit.targetId && coords[exit.targetId]) {
                            renderEdges.push({
                                x1: node.x, y1: node.y - 25, 
                                x2: coords[exit.targetId].x, y2: coords[exit.targetId].y + 25,
                                dir: exit.dir
                            });
                        }
                    });
                });

                Object.keys(stubCoords).forEach(key => {
                    const stub = stubCoords[key];
                    const parent = coords[stub.parentId];
                    if (parent) {
                         renderEdges.push({
                            x1: parent.x, y1: parent.y - 25,
                            x2: stub.x, y2: stub.y + 20,
                            dir: stub.dir, isStub: true
                        });
                        renderStubs.push({
                            id: key,
                            type: 'unknown',
                            x: stub.x,
                            y: stub.y,
                            parentId: stub.parentId,
                            dir: stub.dir
                        });
                    }
                });

                return { renderNodes: [...renderNodes, ...renderStubs], renderEdges };
            };

            const getIcon = (type) => {
                switch(type) {
                    case 'intersection': return <ChevronsUp size={20} className="text-blue-400" />;
                    case 'trap': return <AlertTriangle size={18} className="text-red-500" />;
                    case 'enemy': return <Skull size={18} className="text-orange-500" />;
                    case 'treasure': return <Coins size={18} className="text-yellow-400" />;
                    case 'extra_ball': return <Circle size={18} className="text-gray-300 fill-gray-500" />;
                    case 'stairs': return <ArrowUp size={18} className="text-purple-400" />;
                    case 'unknown': return <span className="text-gray-500 font-bold text-lg">?</span>;
                    default: return null;
                }
            };

            // --- Mobile Control Pad ---
            const ControlPad = () => {
                const isActionAvailable = mode === 'TRANSIT';
                const isConfirmNeeded = mode === 'DEFINING' || (mode === 'IDLE' && cursor.nodeId && getNode(cursor.nodeId)?.type === 'enemy' && getNode(cursor.nodeId).exits.length === 0);

                return (
                    <div className="bg-gray-900 border-t border-gray-800 p-2 grid grid-cols-3 gap-2 shrink-0 md:hidden pb-6">
                        {/* Outcomes Row */}
                        <div className="col-span-3 flex justify-between gap-1 bg-gray-800 p-1 rounded mb-1">
                            <button onClick={() => handleInput('B')} className={`flex-1 py-3 rounded flex justify-center items-center ${isActionAvailable ? 'bg-orange-900/50 text-orange-200' : 'opacity-20'}`}><Skull size={24}/></button>
                            <button onClick={() => handleInput('X')} className={`flex-1 py-3 rounded flex justify-center items-center ${isActionAvailable ? 'bg-red-900/50 text-red-200' : 'opacity-20'}`}><AlertTriangle size={24}/></button>
                            <button onClick={() => handleInput('G')} className={`flex-1 py-3 rounded flex justify-center items-center ${isActionAvailable ? 'bg-yellow-900/50 text-yellow-200' : 'opacity-20'}`}><Coins size={24}/></button>
                            <button onClick={() => handleInput('E')} className={`flex-1 py-3 rounded flex justify-center items-center ${isActionAvailable ? 'bg-gray-700 text-gray-200' : 'opacity-20'}`}><Circle size={18} className="fill-gray-400"/></button>
                            <button onClick={() => handleInput('', 'Space')} className={`flex-1 py-3 rounded flex justify-center items-center ${isActionAvailable ? 'bg-purple-900/50 text-purple-200' : 'opacity-20'}`}><ArrowUp size={24}/></button>
                        </div>

                        {/* Directionals */}
                        <button onClick={() => handleInput('A')} className="bg-gray-800 active:bg-gray-700 rounded flex items-center justify-center h-16 touch-manipulation">
                            <ArrowLeft size={32} className={draftExits.includes('left') ? 'text-green-500' : 'text-white'} />
                        </button>
                        
                        <button onClick={() => handleInput('S')} className="bg-gray-800 active:bg-gray-700 rounded flex items-center justify-center h-16 touch-manipulation">
                            <ArrowUp size={32} className={draftExits.includes('center') ? 'text-green-500' : 'text-white'} />
                        </button>
                        
                        <button onClick={() => handleInput('D')} className="bg-gray-800 active:bg-gray-700 rounded flex items-center justify-center h-16 touch-manipulation">
                            <ArrowRight size={32} className={draftExits.includes('right') ? 'text-green-500' : 'text-white'} />
                        </button>

                        {/* Action Row */}
                        <button onClick={() => handleInput('DELETE')} className="bg-red-900/30 active:bg-red-900/50 rounded flex items-center justify-center text-red-400 font-bold text-xs h-14">
                            RESET
                        </button>
                        
                        <button onClick={() => handleInput('ENTER')} className={`col-span-2 rounded flex items-center justify-center font-black text-xl gap-2 h-14 touch-manipulation transition-all ${isConfirmNeeded ? 'bg-green-600 text-white animate-pulse shadow-[0_0_15px_rgba(22,163,74,0.5)]' : 'bg-gray-700 text-gray-400'}`}>
                            GO <Check size={24}/>
                        </button>
                    </div>
                );
            };

            return (
                <div className="flex flex-col h-screen bg-gray-950 text-gray-200 font-mono overflow-hidden">
                
                {/* Header */}
                <div className="px-4 py-3 bg-gray-900 border-b border-gray-800 flex justify-between items-center z-10 shadow-lg shrink-0">
                    <div className="flex items-center gap-2 min-w-0">
                        <Sword size={20} className="md:block hidden"/> 
                        <span className="font-bold text-sm md:text-lg truncate">{message}</span>
                    </div>
                    <div className="flex gap-2 items-center">
                        <button onClick={handleShare} className="bg-gray-800 text-blue-400 p-1.5 rounded hover:bg-gray-700 active:scale-95 transition-all" title="Share Map">
                            <Share2 size={18}/>
                        </button>
                        <div className="flex gap-1">
                            {[1, 2, 3, 4, 5].map(lvl => (
                            <button key={lvl} onClick={() => startLevel(lvl)} 
                                className={`w-8 h-8 flex items-center justify-center rounded text-sm font-bold transition-all ${currentLevel === lvl ? 'bg-blue-600 text-white shadow-blue-500/50 shadow-md' : 'bg-gray-800 text-gray-500 hover:bg-gray-700'}`}>
                                {lvl}
                            </button>
                            ))}
                        </div>
                    </div>
                </div>

                {/* Main Split View */}
                <div className="flex flex-1 overflow-hidden relative">
                    {maps.map((mapData, index) => {
                    const isLevelActive = currentLevel === (index + 1);
                    const { renderNodes, renderEdges } = computeLayout(index);

                    const hasUnexplored = (nodeId) => {
                        const n = mapData.nodes[nodeId];
                        if (!n) return false;
                        if (n.type === 'enemy' && n.exits.length === 0) return true; 
                        if (n.type === 'unknown') return true; 
                        return n.exits.some(e => !e.targetId || hasUnexplored(e.targetId)); 
                    };

                    return (
                        <div 
                            key={index} 
                            className={`
                                relative border-r border-gray-800 transition-colors duration-500 overflow-auto no-scrollbar
                                ${isLevelActive ? 'flex-1 flex bg-gray-900/50' : 'hidden md:flex md:flex-1 bg-black/60 opacity-60 grayscale-[50%]'}
                            `}
                        >
                        <div className="absolute bottom-4 right-4 text-8xl font-black text-gray-800/50 pointer-events-none select-none">
                            {index + 1}
                        </div>

                        <div className="w-full min-h-full relative">
                            <div className="absolute bottom-[100px] left-1/2 transform -translate-x-1/2 w-0 h-0">
                                
                                <svg className="absolute overflow-visible" style={{ left: 0, top: 0 }}>
                                    {renderEdges.map((edge, i) => (
                                        <g key={i}>
                                        <line 
                                            x1={edge.x1} y1={edge.y1} 
                                            x2={edge.x2} y2={edge.y2} 
                                            stroke={edge.isStub ? "#4b5563" : "#60a5fa"} 
                                            strokeWidth={edge.isStub ? 1 : 2} 
                                            strokeDasharray={edge.isStub ? "3" : "0"}
                                        />
                                        {!edge.isStub && <circle cx={edge.x2} cy={edge.y2} r="2" fill="#60a5fa" />}
                                        </g>
                                    ))}
                                </svg>

                                {renderNodes.map(node => {
                                    const isCursor = isLevelActive && cursor.nodeId === node.id;
                                    const isActiveStub = isLevelActive && mode === 'TRANSIT' && node.type === 'unknown' && 
                                                         node.parentId === cursor.previousNodeId && node.dir === cursor.directionFromPrev;
                                    
                                    const isUnknown = node.type === 'unknown';
                                    const activeClass = isCursor || isActiveStub ? 'ring-2 ring-green-400 bg-gray-800 scale-110 z-20' : '';
                                    
                                    const getExitStatus = (dir) => {
                                        const exit = node.exits?.find(e => e.dir === dir);
                                        if (!exit) return null;
                                        if (!exit.targetId) return 'unexplored';
                                        if (hasUnexplored(exit.targetId)) return 'unexplored';
                                        return 'explored';
                                    };

                                    const leftStatus = isCursor && mode === 'IDLE' && getExitStatus('left');
                                    const rightStatus = isCursor && mode === 'IDLE' && getExitStatus('right');
                                    const centerStatus = isCursor && mode === 'IDLE' && getExitStatus('center');

                                    const getArrowClass = (status) => {
                                        if (status === 'unexplored') return "text-orange-500 animate-pulse filter drop-shadow-lg";
                                        return "text-green-600";
                                    };
                                    
                                    const getArrowSize = (status) => 20;
                                    const getArrowStroke = (status) => status === 'unexplored' ? 3 : 2;

                                    return (
                                        <div 
                                            key={node.id}
                                            onClick={() => handleNodeClick(node, index)}
                                            className={`absolute border-2 flex flex-col items-center justify-center rounded shadow-md transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300 cursor-pointer active:scale-95
                                                ${isUnknown ? 'w-[40px] h-[40px] border-dashed border-gray-700 bg-black/40 z-0' : 'w-[50px] h-[50px] z-10'}
                                                ${activeClass}
                                                ${!isCursor && !isActiveStub && !isUnknown ? 'bg-gray-900 border-gray-700' : ''}
                                                ${node.type === 'trap' ? 'border-red-900/50' : ''}
                                                ${node.type === 'enemy' ? 'border-orange-900/50' : ''}
                                                ${node.type === 'treasure' ? 'border-yellow-900/50' : ''}
                                                ${node.type === 'extra_ball' ? 'border-gray-300' : ''}
                                            `}
                                            style={{ left: node.x, top: node.y }}
                                        >
                                            {node.id === 'root' ? (
                                                <span className="text-2xl font-bold text-gray-500">{index + 1}</span>
                                            ) : (
                                                <>
                                                    {getIcon(node.type)}
                                                    {node.type === 'stairs' && <span className="text-[10px] font-bold text-white mt-0.5">L{node.content}</span>}
                                                </>
                                            )}

                                            {isCursor && mode === 'DEFINING' && (
                                                <div className="absolute inset-0 pointer-events-none">
                                                    {draftExits.includes('left') && <ArrowLeft className="absolute top-1/2 -left-5 text-green-500 animate-pulse" size={16}/>}
                                                    {draftExits.includes('right') && <ArrowRight className="absolute top-1/2 -right-5 text-green-500 animate-pulse" size={16}/>}
                                                    {draftExits.includes('center') && <ArrowUp className="absolute -top-5 left-1/2 -translate-x-1/2 text-green-500 animate-pulse" size={16}/>}
                                                </div>
                                            )}

                                            {isCursor && mode === 'IDLE' && (
                                                <div className="absolute inset-0 pointer-events-none">
                                                    {leftStatus && <ArrowLeft className={`absolute top-1/2 -left-6 ${getArrowClass(leftStatus)}`} size={getArrowSize(leftStatus)} strokeWidth={getArrowStroke(leftStatus)} />}
                                                    {rightStatus && <ArrowRight className={`absolute top-1/2 -right-6 ${getArrowClass(rightStatus)}`} size={getArrowSize(rightStatus)} strokeWidth={getArrowStroke(rightStatus)} />}
                                                    {centerStatus && <ArrowUp className={`absolute -top-6 left-1/2 -translate-x-1/2 ${getArrowClass(centerStatus)}`} size={getArrowSize(centerStatus)} strokeWidth={getArrowStroke(centerStatus)} />}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                        </div>
                    );
                    })}
                </div>

                {/* Desktop Footer Legend */}
                <div className="hidden md:flex px-4 py-2 bg-gray-900 border-t border-gray-800 text-[10px] text-gray-400 justify-center gap-4 flex-wrap shrink-0">
                    <span className="flex items-center gap-1"><ChevronsUp size={12} className="text-blue-400"/> Intersection (A/S/D)</span>
                    <span className="flex items-center gap-1"><Skull size={12} className="text-orange-500"/> Enemy (B)</span>
                    <span className="flex items-center gap-1"><AlertTriangle size={12} className="text-red-500"/> Trap (X)</span>
                    <span className="flex items-center gap-1"><Coins size={12} className="text-yellow-400"/> Treasure (G)</span>
                    <span className="flex items-center gap-1"><Circle size={12} className="text-gray-300 fill-gray-500"/> Extra Ball (E)</span>
                    <span className="flex items-center gap-1 text-green-400 font-bold border-l border-gray-700 pl-2">ENTER=Confirm</span>
                    <span className="flex items-center gap-1 text-red-400 font-bold">DEL=Reset</span>
                </div>

                {/* Mobile Control Pad */}
                <ControlPad />

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DungeonMapper />);
    </script>
</body>
</html>